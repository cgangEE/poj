POJ 1035 Spell checker
给定一个最多有10000个单词的单词表，再给50个单词，求是否能在字典里找到这个单词，或者求删除、增加、替换可得到在字典里的单词。
Hash 一开始直接查找。如果没找到，则暴力枚举删除、增加、替换的得到的单词，进行hash查找。

POJ 3080 Blue Jeans
给定最多十个长度为60的字符串，求这些字符串的最长且字典序最小的公共子串。
模拟 先在第0、1两个串里枚举公共子串，然后再在剩余的串中查找是否有该子串。

POJ 1936 All in All
求一个字符串是否是另一个字符串的子序列。
模拟 有两个指针i、j分别指向字符串s、t，求解s是否是t的子序列。

POJ 2388 Who's in the Middle
求数列的中位数。
排序 排序后求中位数。

POJ 2299 Ultra-QuickSort
一个长度为n的序列，求最小相邻的交换次数使序列有序。
归并排序 最小相邻交换次数=逆序数，用归并排序求逆序对数。

POJ 3349 Snowflake Snow Snowflakes
求n个雪花中是否有同构的雪花。
Hash 先对雪花的各个方位枚举，求出字典序最小的状态，然后对该状态进行hash。

POJ 3274 Gold Balanced Lineup
给定 n<=100000 个 k<=30 bit位数，求最长的连续的一段，是该段每一bit的频数相等。
Hash 令s[i][j]为1..i序列第 j bit位的和，如果第a到b段每一bit的频数都相等，则s[b][k]-s[a][k]=C，对于任意k，C为常数。gao(s[i])为,对于所有k，s[i][k]-=min(s[i][k])，对于相等的gao(s[a]),gao(s[b])，那么一定存在常数C=min(s[a])-min(s[b])，为任意一bit，s[a]与s[b]的差距。
