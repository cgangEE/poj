POJ 2528 Mayor's posters
在长<=10^7一个墙上贴<=10000与墙同样高的、有一定长度的海报，旧的海报会被新贴的海报覆盖，问最后可以看到多少张海报。
线段树+离散化 将线段插入数中，最后统计树上还有多少种线段。

POJ 2828 Buy Tickets
n个人排队，每个人都会插队，给定每个人插队的位子，在这个人插队的位置之后的人都退后一个位置，求最后所有人的排位。
线段树 如果一个人插队，相当与在原来已有的队列里的一个位置上插入一个人，即插入一个节点；如果从后向前看，相当与一个长度为n的队列，在该位置删除一个人，用线段树的做法，可用线段树来实现删除操作。

POJ 2777 Count Color
给一个最长为100000的板子染最多不超过30种颜色，每次有两种操作，一是将i到j染成颜色C，而是询问i到j有多少种不同的颜色。
线段树 采用懒惰标记对线段进行染色，用整数的二进制的第几位是1来表示是否染了该颜色。

POJ 2886 Who Gets the Most Candies?
n个儿童顺时针排成一个圈，第i个儿童有一个数字a[i]，一开始第K个儿童跳出来，然后当前儿童左边第a[k]个儿童跳出来，如此循环，直到所有儿童跳出来，求第m个跳出来的名字，m满足能整除m的整数最多。
线段树 先查找当前位置之前有多少没跳出的儿童，在加上a[k]取余就是当前要跳出的儿童。

POJ 2750 Potted Flower
给定n个数顺时针拼成一个圈，有m次对圈上任意元素的修改，对于每一次修改，求长度小于n的最大子段和。
线段树+最大子段和 利用线段树求1..n序列的最大子段和Max，和最小子段和Min，答案就是max(Max, Sum-Min)，如果Max==Sum，那么答案就是Sum-Min。

POJ 2482 Stars in Your Window
给定最多10000个星星的坐标和亮度，和一个长宽为W*H的矩形，求能套住星星的亮度之和最大。
扫描线+线段树+最大前缀 将星星按照x坐标排序，每次插入一个新元素，就将与之长度大于w的星星删除。由于y坐标的范围为2^31-1，所以要对y轴坐标离散化。每次插入每个节点的y坐标的亮度，要在y+H出插入一个亮度的相反数，再用线段树求最大前缀。

POJ 2352 Stars
给定N个星星的坐标，一个星星的等级就是在他的左下方有多少个星星，求出各个等级星星的数量。
线段树 对N个星星按照x，y排序，然后分别把y坐标插入线段树，然后统计小于当前y坐标的数量就是该星星的等级。

POJ 1195 Mobile phones
给定一个S*S的矩阵，有两种操作一种是对矩阵某一元素整加k，一种是统计一个子矩阵元素之和。
二维树状数组 用二维树状数组可以统计[1..x][1..y]的元素之和，通过容斥原理就可以计算出任意子矩阵之和了。

POJ 3321 Apple Tree
给定一颗树，有两种操作，一是对树上某个节点上是否有苹果取反，而是查询一颗子树上有多少个苹果。
树状数组 对树进行后续遍历得到树上节点的编号，也可得到其子树节点编号的区间，利用树状数组可更新某节点和求得该区间之和。

POJ 3264 Balanced Lineup
给定一个序列，有m个询问是一个区间最大值和最小值之差。
线段树 用线段树查询一个区间的最大值和最小值求差。

POJ 3368 Frequent values
给定一个不降序列，给定一个区间，求该区间的某个数的最大频数。
线段树 对于每个数的频数插入到线段树中，对于给定的询问区间，求出两段的标号x，y，在线段树中查询[x+1,y-1]的频数，在计算出x和y的频数，取最大值。

POJ 1703 Find them, Catch them
给定n个人分别属于两个不同的组织，m个操作，一个是说a和b属于不同组织，一个是询问a和b的关系，是属于同一个组织还是不同，还是不知道。
并查集 用并查集来维护属于同一个组织的人，对于每个a、b互相是对立的，将与原来与a对立的与b合并到一个集合，原来与b对立的和a合并到一个集合。

POJ 2492 A Bug's Life
虫子有两个性别，给定n队虫子的交互，判断是否只有异性才会交互。
并查集 用并查集来维护同一性别的虫子，对同一性别的虫子进行查找，合并。

POJ 1961 Period
对于给定的字符串每一个前缀，求其最多有多少个周期。
KMP 对于MP算法求得的next数组，表示的是s[0..next[i]-1]==s[i-next[i] ..i-1], 如果i-next[i]能整除i的话，那么0..i-1这个前缀的周期数就是大于1的，且周期数就为i/(i-next[i]);

POJ 2406 Power String
对于给定的字符串，求其最多有多少个周期。
KMP 对于MP算法求得的next数组，表示是s[0..f[n]-1]==s[n-f[n]..n-1]，如果n-f[n]能整除n，那么该字符串的周期数就大于1，且周期数为n/(n-f[n])。
